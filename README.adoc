:toc:

= tsugou-kun-react

[%hardbreaks]
調整さん （https://chouseisan.com/ ）のパクりサービス。リスペクト！
React・TypeScript・Expressの習得用に開発している。


== ■動作手順
[%hardbreaks]
開発工程用サーバ起動手順を示す。
本プロジェクトでは、バックエンド用・フロントエンド用サーバを分けて開発している。
（2020/09/26現在、一緒にビルドする方法が分からないのと、効率が良さそうだと感じたため）

下記にバックエンドサーバ、フロントエンドサーバの順に動作手順を示す。

1. clone
1. バックエンドサーバセットアップのため、下記コマンドを実行する。
+
```shell
$ PJ_HOME=`pwd`/tsugou-kun-react
$ cd ${PJ_HOME}/backend
$ npm ci
$ cd ${PJ_HOME}/backend/src/db
$ ${PJ_HOME}/backend/node_modules/sequelize-cli/lib/sequelize db:migrate --env development
$ mv ${PJ_HOME}/backend/src/db/data/tsugoukun_development.sqlite3 ${PJ_HOME}/backend/data/
$ cd ${PJ_HOME}/backend
$ npm start
```
1. フロントエンドサーバセットアップのため、下記コマンドを実行する。
+
```shell
$ cd ${PJ_HOME}/frontend
$ npm ci
$ npm start
```


== ■今後の開発用メモ

=== ▼コンポーネント分類
==== ◎Presentational Component
* 見た目を担当するコンポーネント
* 独自のマークアップとスタイルを持つ
* 多くの場合this.props.childrenとして他に内包される
* アクションやストアに依存しない
* データのロードや変更などのロジックの部分は切り離される
* propsとしてデータとコールバックを受け取れる
* 稀に独自のstateを持つ、それはデータではなくUIの状態として持つ
* Presentational Component例：Page, Sidebar, Story, UserInfo, Listが上げられる
* 基本的にstateには触らず、propsとして与えられるデータを表示することに専念
* storeにもアクセスしない。dispatchもできない。
* 例えばボタンを表示しても、onClickではpropsで与えられるコールバック関数を呼ぶだけ
* 表示するデータや、ボタン押下時の処理を外部から指定することができ、再利用性が上がる
* dropdownの開閉状態のような、componentの中に閉じ込めた方が良いと判断されるデータの管理には
  stateを使うこともありる。そういうのは大抵UIに関する状態管理である。
  アプリケーションの状態やデータはReduxのstoreに格納し、container comoponentからアクセスすることになる。

==== ◎Container Components
* ロジック（物事の振る舞い）に関与する。
* 通常、ラッピングのdivを除いて独自のDOMマークアップはもたない
* Presentational Componentまたその他のコンポーネントにデータと振る舞いを提供する
* アクション呼び出しなどをコールバックとしてPresentational Componentに渡す
* スタイルなどを持たないという点から、データソースとして機能する傾向があるため、基本的に状態保持と処理を行う
* React Reduxのconnect（）、RelayのcreateContainer （）、Flux UtilsのContainer.create（）などの上位コンポーネントを使用して生成される。
* 例としてUserPage、FollowersSidebar、StoryContainer、FollowedUserListが上げられる

==== ◎備考
[%hardbreaks]
ただし、この分類を提唱したDan Abramovは、「Hooksがある現状では、分割は勧めていない。（2019）」と言っている。
※元々分割を推奨した理由は、「複雑なステートフルロジックをコンポーネントの
　他の側面から切り離すことができたから」とのこと。
※ https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0



=== ▼Component実装ルール
※参考： https://moneyforward.com/engineers_blog/2020/02/18/react-component-rules/

* Atomic Designを意識する
  - 各レベルのルール
  - 自分のレベル以下の要素で構成する
  - 最初から完璧に設計する必要はない
* ファイルの命名規則
* Functional Componentで実装する
* Container ComponentとPresentational Componentに分けて実装する
* Templates以下のComponentではuseQuery・useMutationを実行しない
* global state と local stateの使い分け
  ** 下記はglobal
     *** そのデータがUI上関連の無いComponent同士で参照される時 +
         ※ヘッダーとサイドメニューでユーザー情報を参照するなど
     *** そのデータから派生データを作成する必要がある時
* スタイル管理
* その他
  ** 名前を間違えずにimport/exportするため、export defaultを使用しない +
     *** default exportの場合はimportの際に自由に名前をつけることができるため、 +
         typoに気づけない、export先の名前が統一されないケースがある。 +
         また、IDEでのコード補完とも相性が悪い。
  ** Componentを作成する際はclassNameを受け取ることが可能なようにpropsを定義する
  ** Material-UIを利用する
* Componentの利用
  - RailsのViewへのReact Componentの埋め込み
  - client/Components/other/以下のComponentは原則利用しない
* 親コンポーネントが子コンポーネントの具体的なデータや発行する Action を知りすぎないよう、
  またひとつのコンポーネントの Props が５個や６個以上にならないよう調整していくといい
* Presentaitona Component が Container Component を、Container Component が
  Presentational Component を呼ぶのはいいが、Container が Container を呼ぶのは
  どこでデータが上書きされるかが複雑に絡み合ってややこしくなるので、できれば避けたほうがいい


=== ▼開発プロセス
. ページをコンポーネントの階層構造に落とし込み、併せて各コンポーネントの Props を決定する
. どのコンポーネントを Container にするかを決め、その Local State および connect するProps を決定する +
     UI 状態を表現する必要かつ十分な state を決定する +
     state をどこに配置するべきなのかを明確にする
. ページを構成する主要なコンポーネントを、スタイルガイドとして Storybook に登録する +
     Container にするべきコンポーネントが決まったら、ページを構成する主要な +
     Presentational Component を Storybook にスタイルガイドとして登録する
. Container が発行する Action と発行に使う Action Creator を作成、それに対応する Reducerも併せて作る
. その Action が必要とする API ハンドラを作成、ユニットテストも併せて書く +
     4.の Action に対応した Saga を作成する。それができたら Redux DevTools から +
     生テキストのAction を Dispatch してみて、その Saga が正しく動作することを確認。 +
     その上で Redux SagaTest Plan を用いて Saga と Reducer のユニットテストを書く。 +
. 4 と 5 による Saga を作成、ユニットテストも併せて書く
. Container Component を作成する
. 正常系の E2E テストをCypressで作成する


=== ▼テスト方針
・ロジックのテストはちゃんとやる。
  ※API ハンドラや Redux-Saga の Saga 群。
・コンポーネントに関しては、費用対効果を考えて最小限にする
・Storybook にストーリー登録したPresentational Component のスナップショットテストを行う。
・全体的な動作の保証のために、自動化された E2E テストを正常系に限って行う。



== ■開発者用メモ

自分が辿った道を残す。

=== ▼開発環境構築

==== ◎バックエンド側

プロジェクトフォルダ・TypeScript・Expressの準備を行う。

```shell
$ mkdir backend; cd backend
$ npm init
$ npm i -D \
    typescript \
    ts-node \
    ts-node-dev \
    sequelize-cli \
    tslint \
    @types/node \
    @types/express \
    @types/sqlite3
$ npm i \
    express \
    sqlite3 \
    sequelize \
    base64url \
    mocha \
    @types/mocha
$ tsc --version
$ tsc --init
```

===== ○DBマイグレーション・モデル初期構築

```shell
$ mkdir src/db
$ cd src/db
$ ../../node_modules/sequelize-cli/lib/sequelize init
$ ls
config/  migrations/  models/  seeders/
＜この間で config/config.json の接続先等を編集＞
$ ../../node_modules/sequelize-cli/lib/sequelize model:create \
    --name moyooshi \
    --underscored \
    --attributes \
        "name:string \
        ,memo:string \
        ,schedule_update_id:string"
$ ../../node_modules/sequelize-cli/lib/sequelize model:create \
    --name moyooshikouho_nichiji \
    --underscored \
    --attributes \
        "kouho_nichiji:string \
        ,moyooshi_id:bigint \
        ,schedule_update_id:string"
$ ../../node_modules/sequelize-cli/lib/sequelize model:create \
    --name sankasha \
    --underscored \
    --attributes \
        "name:string \
        ,moyooshi_id:bigint \
        ,comment:string"
$ ../../node_modules/sequelize-cli/lib/sequelize model:create \
    --name sanka_nichiji \
    --underscored \
    --attributes \
        "sanka_kahi:enum \
        ,event_kouho_nichiji_id:bigint \
        ,sankasha_id:bigint"
＜ここで、migration/とmodels/配下のソースに、非null制約・外部キー関連の設定（キーワード：associate, references）を行う＞
$ ../../node_modules/sequelize-cli/lib/sequelize db:migrate --env development
＜ここで、src/db/data配下に出力される.sqlite3ファイルを、data/に移動する＞

```


==== ◎フロントエンド側


===== ○実行コマンド
プロジェクトフォルダ・TypeScript・Webpack・ReactJSの準備を行う。

```shell
$ mkdir frontend; cd frontend
$ npm init
$ npm i -D \
    typescript \
    ts-loader \
    tslint \
    @types/react \
    @types/react-dom \
    @types/react-redux \
    @types/react-router-dom \
    webpack \
    webpack-cli \
    webpack-dev-server \
    clean-webpack-plugin \
    html-webpack-plugin \
    style-loader \
    css-loader
$ npm i \
    react \
    react-dom \
    redux \
    react-redux \
    redux-saga \
    @reduxjs/toolkit \
    axios \
    react-router@next \
    react-router-dom@next \
    history \
    redux-actions \
    react-bootstrap \
    bootstrap \
    react-modern-calendar-datepicker \
    react-helmet
$ tsc --version
$ tsc --init
※React Routerについてはβ版の6を使用。競合のReach Routerとの合併版であり、便利かつ直感的であるため。正式版がリリースされ次第「@next」を除去する。
# for test
$ npm i -D jest \
    ts-jest \
    jest-environment-jsdom-fourteen \
    @testing-library/react \
    @testing-library/user-event \
    @testing-library/jest-dom \
    @types/jest \
    @babel/preset-react \
    babel-preset-react-app
```

※ts-node：コンパイルした後にnodeで実行してくれるモジュール。 +
　package.jsonのscriptsに `ts-node` を実行するコマンドを定義する。

===== ○フォルダ構成
[%hardbreaks]
https://qiita.com/tashxii/items/0515f00ec641d52f879b[React+Redux+APIサーバーでのアプリケーションのディレクトリ/ファイル構成]
この記事での考え方が一番しっくり来たため採用。



=== ▼参照資料

* https://qiita.com/pochopocho13/items/79a4735031ce11a91df7[Node+TypeScript+ExpressでAPIサーバ構築]
* https://ics.media/entry/16329/[最新版TypeScript+webpack 4の環境構築まとめ(React, Vue.js, Three.jsのサンプル付き)]
* https://qiita.com/niyou0ct/items/cc09ed42a6a51cf2a8b1[ReactでAPI処理はredux-sagaを使うのがオススメ！]
* https://qiita.com/pullphone/items/fdb0f36d8b4e5c0ae893[ざっくり React & Redux with TypeScript]
* https://qiita.com/kuy/items/716affc808ebb3e1e8ac[★redux-sagaで非同期処理と戦う]
* https://www.hypertextcandy.com/react-error-handling[Reactアプリにおける非同期通信エラー処理の実装案]
* https://blog.capilano-fw.com/?p=5582[保存版！「sequelize」モデルの使い方実例・全59件]